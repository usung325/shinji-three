/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import * as THREE from "three";

export function Cross4({ normalVec3 }) {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF("/models/cross.glb");
  const { actions } = useAnimations(animations, group);

  useEffect(() => {
    if (!actions.Expand) {
      console.log("actions not loaded");
      return;
    }

    const expand = actions.Expand;

    // expand.reset();
    expand.repetitions = false;
    expand.clampWhenFinished = true;
    expand.play();

    // return () => {
    //   expand.stop();
    // };
  }, []);

  useEffect(() => {
    /////GPT//////////GPT//////////[IT KIND OF WORKS]/////////GPT//////////GPT/////
    // // Convert normal to orientation vectors
    // const up = new THREE.Vector3(0, 1, 0);

    // // Calculate the rotation axis by crossing the up vector with the normal
    // const rotationAxis = new THREE.Vector3().crossVectors(up, normalVec3);

    // // Calculate the angle between the up vector and normal
    // const angle = Math.acos(up.dot(normalVec3));

    // // Apply the rotation
    // group.current.setRotationFromAxisAngle(rotationAxis, angle);
    /////GPT//////////GPT//////////GPT//////////GPT//////////GPT/////
    // Convert normal to orientation vectors
    const up = new THREE.Vector3(0, 1, 0);

    // Calculate the rotation axis by crossing the up vector with the normal
    const rotationAxis = new THREE.Vector3().crossVectors(up, normalVec3);

    // Calculate the angle between the up vector and normal
    const angle = Math.acos(up.dot(normalVec3));

    // Create a rotation matrix for aligning with the normal
    const alignMatrix = new THREE.Matrix4();
    alignMatrix.makeRotationAxis(rotationAxis, angle);

    // Generate random angle for z-axis rotation (in radians)
    const randomZRotation = Math.random() * Math.PI * 2;

    // Create a rotation matrix for the z-axis rotation
    const zRotationMatrix = new THREE.Matrix4();
    zRotationMatrix.makeRotationAxis(normalVec3.normalize(), randomZRotation);

    // Combine the rotations by multiplying the matrices
    const finalMatrix = new THREE.Matrix4();
    finalMatrix.multiplyMatrices(zRotationMatrix, alignMatrix);

    // Apply the combined rotation to the group
    group.current.setRotationFromMatrix(finalMatrix);
    /////GPT//////////GPT//////////GPT//////////GPT//////////GPT/////
  }, [normalVec3]);

  return (
    <group ref={group} dispose={null}>
      <group name="Scene">
        <mesh
          name="Cube001"
          //   castShadow
          //   receiveShadow
          geometry={nodes.Cube001.geometry}
          material={nodes.Cube001.material}
          //   position={[0, 0.334, 0]}
          scale={[0.001, 0.011, 0.001]}
        >
          <meshStandardMaterial
            color={[0.3 + 0.3, 1.0 + 0.3, 0.4 + 0.3]}
            emissive="#9BD495"
            emissiveIntensity={1}
            toneMapped={false}
          />
        </mesh>
      </group>
    </group>
  );
}

useGLTF.preload("/models/cross.glb");
